/*
    * Метод WebApplication.CreateBuilder(args) является одним из способов создания 
      объекта IHostBuilder, который используется для создания и настройки хоста веб-приложения, 
      а также для конфигурации этого хоста и приложения. IHostBuilder предоставляет набор 
      методов для настройки различных аспектов хоста и приложения, таких как настройка 
      конфигурации, добавление служб, настройка статических файлов, маршрутизации и других. 

    * Метод WebApplication.CreateBuilder(args) создает новый экземпляр IHostBuilder 
      и настраивает его некоторыми базовыми параметрами, используя аргументы командной 
      строки args. Эти аргументы могут быть переданы в приложение при его запуске 
      и используются для настройки и конфигурации различных параметров приложения. 
      После создания объекта IHostBuilder, вы можете использовать его для настройки 
      и конфигурации хоста и приложения, добавления служб, внедрения зависимостей 
      и других операций. Например, вы можете добавить службы, используя метод 
      ConfigureServices, настроить конфигурацию приложения с помощью метода 
      ConfigureAppConfiguration и т.д.
*/

var builder = WebApplication.CreateBuilder(args);

/*
    * В коде builder.Services.AddControllers() происходит добавление службы 
      для обработки контроллеров в приложении.

    * AddControllers() является методом расширения для объекта IServiceCollection, 
      который представляет контейнер для регистрации служб в ASP.NET Core приложении. 
      Вызов этого метода говорит контейнеру зарегистрировать все контроллеры в приложении.

    * Контроллеры в ASP.NET Core отвечают за обработку HTTP-запросов и возвращение 
      результатов. Добавление службы AddControllers() позволяет приложению знать 
      о контроллерах и обрабатывать соответствующие запросы.

    * После этого вызова контейнер будет знать о контроллерах в приложении, 
      и будет способен создавать экземпляры контроллеров и передавать им необходимые 
      зависимости, если такие имеются. Это делает использование контроллеров 
      в ASP.NET Core более удобным, так как контейнер управляет созданием 
      экземпляров и разрешением зависимостей автоматически.
*/
builder.Services.AddControllers();

/*
    * В коде builder.Services.AddEndpointsApiExplorer() выполняется регистрация службы 
      для API Explorer внутри приложения ASP.NET Core.

    * API Explorer предоставляет инфраструктуру для изучения и отображения информации 
      о точках входа (endpoints) в вашем веб-приложении. Он собирает метаданные об 
      этих точках входа (например, маршруты, атрибуты, типы параметров 
      и возвращаемые значения) и предоставляет их в виде структурированного API.

    * Чтобы использовать API Explorer, необходимо добавить пакет NuGet 
      Microsoft.AspNetCore.Mvc.ApiExplorer. После этого вы можете использовать 
      API Explorer для генерации документации, автоматической генерации 
      клиентского кода, отладки и других сценариев, связанных 
      с изучением и пониманием вашего API.
*/
builder.Services.AddEndpointsApiExplorer();

/*
    * В коде builder.Services.AddSwaggerGen() происходит добавление Swagger в конфигурацию 
      внедрения зависимостей в ASP.NET Core приложении.

    * Swagger является инструментом для создания интерактивной документации API. 
      Он позволяет генерировать автоматическую документацию, проверять запросы 
      и просматривать ответы прямо во время разработки.

    * AddSwaggerGen() — это метод, который добавляет Swagger в конфигурацию приложения. 
      Он регистрирует различные сервисы и настройки Swagger в контейнере внедрения зависимостей.

    * С использованием Swagger в проекте позволяет автоматически генерировать 
      документацию по API на основе кода приложения. После добавления этого метода, 
      вы можете запустить приложение и открыть интерактивную документацию Swagger, 
      основанную на вашем API.
*/
builder.Services.AddSwaggerGen();

/*
    * Эта строка кода на языке C# использует библиотеку .NET Core для регистрации сервиса 
      в контейнере зависимостей. Это часто делается в методе ConfigureServices файла 
      Startup.cs в приложениях .NET Core.

    * Вот его разбивка:

        * builder.Services представляет сервисы, доступные для вашего приложения. 
          Это коллекция, которую ASP.NET Core манипулирует, чтобы определить, 
          какие сервисы (то есть зависимости) доступны в вашем приложении.

        * AddScoped — это метод, который используется для регистрации сервиса 
          с определенной продолжительностью жизни. В данном случае это "scoped" 
          продолжительность жизни, что означает, что для каждого запроса будет 
          создан единственный экземпляр этого сервиса. Другие варианты включают 
          "transient" (отдельный экземпляр для каждого использования) и "singleton" 
          (один экземпляр на всё приложение) :

                * Transient (Мимолетный): В случае использования мимолетного варианта каждый 
                  запрос на создание объекта порождает новый экземпляр. Это означает, что каждый 
                  раз, когда объект нужен, создаётся новый экземпляр для удовлетворения этого 
                  запроса. Это полезно в ситуациях, когда требуется использовать объект только 
                  в определенный момент времени и не требуется сохранять его состояние для 
                  будущего использования.

                * Singleton (Одиночка): Вариант "одиночка" предполагает, что в приложении 
                  существует только один экземпляр объекта. Это означает, что все запросы 
                  на создание объекта будут возвращать ссылку на один и тот же экземпляр. 
                  При этом обычно используется глобальный доступ к этому экземпляру. 
                  Одиночка может быть полезен, когда необходим один объект для координации 
                  действий разных компонентов в приложении или при использовании ресурсов, 
                  которые должны быть глобально доступными.
                
                * Object pool (пул объектов): Подразумевает наличие заранее созданных объектов, 
                  которые могут быть арендованы и освобождены для использования. Это позволяет 
                  избежать накладных расходов на создание и уничтожение объектов во время 
                  выполнения. 

                * Object factory (фабрика объектов): Отвечает за создание объектов с определенными 
                  параметрами или отвечает за выбор конкретной реализации объекта на основе 
                  заданных условий.

        * ISuperHeroService, SuperHeroService говорит о том, что когда ваше приложение 
          требуется сервис типа ISuperHeroService, SuperHeroService будет использоваться 
          для его реализации. По сути, это позволяет каждой другой части вашего приложения, 
          которая зависит от ISuperHeroService, автоматически получить экземпляр SuperHeroService 
          на каждый новый запрос.

    * В общем, этот код позволяет системе сопоставить интерфейс ISuperHeroService с его 
      реализацией SuperHeroService и управлять его жизненным циклом на уровне запроса. 
      Это часть того, что называется "внедрением зависимостей" (Dependency Injection, DI) 
      и позволяет создавать более модульный, тестируемый и управляемый код.
*/
builder.Services.AddScoped<ISuperHeroService, SuperHeroService>();

/*
    * Является технологией доступа к данным от Microsoft, которая позволяет работать с базами 
      данных с использованием .NET объектов.

    * builder.Services.AddDbContext<DataContext>(); - этот код добавляет сервис контекста 
      данных DataContext в контейнер DI (Dependency Injection) приложения ASP.NET Core.

    * AddDbContext - это расширяющий метод, предназначенный для упрощения настройки 
      и использования контекстов Entity Framework Core в приложении.

    * DataContext - это класс, который вы сами создаете, наследуя от DbContext, 
      который представляет единицу работы с базой данных.

    * Далее DataContext можно внедрить в контроллеры или другие сервисы через конструктор. 
      Dependency Injection Container автоматически управляет жизненным циклом созданных 
      контекстов данных - это означает, что когда ваш контроллер или сервис уничтожается 
      после обработки запроса, то и контекст данных также уничтожается, освобождая ресурсы.
*/
builder.Services.AddDbContext<DataContext>();

/*
    * Шаблон инициализации приложения, который используется в .NET Core 3.1 и выше. 
      Этот шаблон упрощает создание и конфигурацию объектов Host и Startup 
      для вашего приложения.

    * В этом контексте builder является экземпляром класса HostBuilder 
      или WebHostBuilder. Этот класс предоставляет метод Build(), который 
      используется для создания хоста для приложения на основе 
      сконфигурированных сервисов и параметров.

    * При вызове builder.Build(), происходят следующие действия:

        * Создается экземпляр класса WebApplication, который представляет ваше приложение.
        * Все зарегистрированные и сконфигурированные в builder сервисы 
          и параметры передаются в этот новый экземпляр WebApplication.
        * Этот экземпляр приложения затем используется для настройки конвейера 
          middleware вашего приложения и указания, как ваше приложение будет 
          отвечать на входящие запросы.
*/
var app = builder.Build();

/*
    * Этот код-фрагмент относится к использованию Swagger для документирования 
      и тестирования API.

    * app.Environment.IsDevelopment(): Это условие проверяет, выполняется ли приложение 
      в окружении разработки. Это также контролируется переменной окружения 
      ASPNETCORE_ENVIRONMENT.

    * app.UseSwagger();: Этот метод подключает Swagger middleware к конвейеру 
      обработки запросов. Swagger - это набор открытых инструментов, предназначенных 
      для работы с RESTful API. Конкретно, Swagger может сгенерировать машинно-читаемое 
      описание API, что особенно полезно для создания живой документации и клиентских библиотек.

    * app.UseSwaggerUI();: Подключает интерфейс пользователя Swagger к приложению. 
      Swagger UI позволяет просматривать документацию API в веб-браузере и даже 
      отправлять запросы к API через браузер.

    * Таким образом, весь этот блок кода делает Swagger и Swagger UI доступными, 
      когда приложение выполняется в окружении разработки.

    * Хотя Swagger очень полезен во время разработки, вы, возможно, не захотите 
      его подключать в производственном окружении, поэтому он оборачивается в проверку 
      app.Environment.IsDevelopment().
*/
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

/*
    * В коде, вызывается метод UseHttpsRedirection() для объекта app.
      Предназначен для перенаправления HTTP-запросов на HTTPS.

    * Когда вызывается этот метод в методе Configure() класса Startup, он добавляет 
      промежуточное ПО (middleware) в конвейер обработки запросов. Если входящий 
      запрос не является защищенным HTTPS-соединением, промежуточное ПО автоматически 
      выполняет перенаправление на соответствующий защищенный адрес URL.

    * Применение перенаправления с HTTP на HTTPS помогает обеспечить безопасность 
      соединений и защитить передаваемые данные, особенно при передаче конфиденциальной 
      или чувствительной информации, такой как логин и пароль пользователей или данные платежей.
*/
app.UseHttpsRedirection();

/*
    * app.UseAuthorization() Нужен для настройки промежуточного программного обеспечения 
      (middleware) авторизации в приложении.

    * Промежуточное программное обеспечение авторизации используется для проверки 
      разрешений доступа пользователя к определенным ресурсам или действиям в приложении. 
      Оно обычно выполняет аутентификацию пользователя (проверку его идентификационных данных) 
      и затем определяет, имеет ли пользователь достаточно прав доступа для выполнения 
      определенных операций.

app.UseAuthorization() должен быть вызван после app.UseAuthentication(), чтобы включить оба промежуточных программных обеспечения в конвейер обработки запросов приложения.

Когда запрос поступает в приложение, промежуточное программное обеспечение авторизации проверяет данные аутентификации пользователя (если они предоставлены) и, опираясь на указанные правила авторизации, принимает решение о том, имеет ли пользователь право на доступ к запрашиваемому ресурсу или действию. Если пользователь не авторизован или не имеет достаточных прав доступа, ему возвращается соответствующий HTTP-код ошибки или иное предназначенное сообщение.

Использование app.UseAuthorization() обычно связано с наличием атрибутов авторизации на контроллерах или действиях, определяющих правила доступа к конкретным частям приложения.
*/
app.UseAuthorization();

/*
    * Предоставляет маршрутизацию HTTP-запросов к контроллерам в вашем приложении.

    * Когда вы вызываете app.MapControllers() в методе Configure() вашего класса Startup, 
      он настраивает сервер для прослушивания и обработки HTTP-запросов, направленных 
      к контроллерам вашего приложения.

    * При использовании app.MapControllers(), ваше приложение будет обслуживать 
      HTTP-запросы и определенным образом маршрутизировать их к соответствующим 
      методам в ваших контроллерах, основываясь на URL-пути и HTTP-методе 
      (например, GET, POST, PUT и т. д.).

    * Это позволяет вам организовать действия вашего веб-приложения через контроллеры, 
      которые обрабатывают разные типы запросов к определенным маршрутам.

    * Например, если у вас есть контроллер UserController с методом GetUser(), 
      и вы настроили app.MapControllers(), то запрос к URL-пути /user с методом GET 
      будет автоматически маршрутизирован к методу GetUser() контроллера UserController.
*/
app.MapControllers();

app.Run();
